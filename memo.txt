webサイトのアプリ化。

reactはhtml/cssをオブジェクト、javascriptの一部として扱う。
→web制作の主体はjavascript！

reactDOMでAPIを使った面倒なdom操作は必要なくなる。

reactのhtml要素はreact要素として扱われる。「AST（抽象化構文木）」化したhtmlを元にオブジェクト生成。

JSXはHTMLに見えるがJSの構文の拡張。
ただJSのコードとして実行することはできない。コンパイルが必要。

Reactを使うためにはレンダリング先の準備にJSXをコンパイルする環境を用意し、
JSによるページ制作なのでバンドラーも整える必要がある。
→Next.jsが面倒見る。

トランスパイラーはプログラミング言語を別のプログラミング言語に変換するもの。
JSX→JSはReactのドキュメントではコンパイルとなる。

ASTは簡単にいうと
<h1>hello</h1>を
{"h1", null, "Hello"}といった形のデータにすること。
属性も含めて構造が明確になることからHTMlの処理に便利なデータ構造。

Next.jsはSSR。SGもページ単位で可能。一般的なSSGよりもSGの柔軟な対応が可能。
ただし、SSRベースなのでNode.jsによるサーバーが必要。
そのためデプロイ先を選ぶことになる。
SSGとして使うことも可だが、Next.jsの重要な機能が使えなくなる。

npxは本来ローカルにインストールされているJSのパッケージを実行するためのもの。
しかしローカルにないパッケージを指定した場合は、一時的にグローバルにダウンロードした上で
実行し削除してくれる。

npmはバージョン管理システム。
・パッケージとしてのデータベースのレジストリ。
・そのレジストリをメンテナンスするためのwebサイト。
・レジストリを利用するためのCLI。
から構成。

package.jsonにscriptsとして登録されてるものは
npm run dev もしくは npx next devで。
scriptsは登録されてるのもは編集してカスタマイズ可能。

next devで開発モードで起動。http://localhost:3000などでプレビューできる。
port指定は-pで。-Hでipaddress表示。

next buildでビルド。

npx startで本番モード。開発モードはプレビュー用なのでたとえばCSSの適用順が異なるとかあるので
最終的な確認は本番モードで。
ここもportやipaddress指定可能。

eslintで文法チェック。

next.jsにはfile-system based routerというものが機能。pageディレクトリにページを用意するだけで
ファイル名をurlとしたページ作成が可能。

デフォルトエクスポートなため1モジュール（ファイル）にひとつとなり、ファイル名との紐付けも問題ない。
↓
ページとなるコンポーネントを作成するのがNext.jsにおいてのページ作成。

import/exportそれぞれ名前付きエクスポートとデフォルトエクスポートがある。

jsxは最上位の要素はひとつ。

変数に代入する際も
export default function Home() {
  const test = (
    <div>
      <h1>hello</h1>
      <p>hello</p>
    </div>
  )
}
↑divがないとエラー。

最上位のdivの代わりに<React.Fragment>もしくは<></>が使用可能。

<></>はいいがkey属性が必要な場合は<React.Fragment>を使う。

<hr /><img />のように閉じないといけない。

「class」でも使えるがワーニング扱い。
「classname」とする。多くのコンポーネントがclassnameを使用。

styleは{{}}の中に書く。キャメルケースのオブジェクトで。

式は{}の中に。変数や関数なども。

複数行では()に入れる。

JSXはあくまでjavascriotのコード。

（setup.pdfより）
next.jsを使うためにはnode.jsによるサーバーが必要。
node.jsはバージョンを管理することもあるため、node.js自身をインストールするには
node.jsのバージョン管理ツールがおすすめ。

従来のweb制作ではcssを的確に当てるため、各要素にユニークなクラス名を振ったが、ページの
構成要素はコンポーネントに分け、スコープされる形でcssを当てていく。

let,const(値への読み取り専用),参照,スコープ、ブロックスコープなど。
※スコープは子から親への参照は可能。逆は不可。

コンポーネント名は必ず大文字で始まる。

propsと書くのもいいが分割代入だとよりスッキリに。
※変数名とプロパティ名は一致している必要がある。

属性を使わずに、
const props1 = {
    title: 'タイトル１',
    url: 'post1.html'
}
を
<EachPost {...props1} />と渡すこともできる。

props.childrenで子要素を渡すこともできる。
コンポーネント名（props）もしくは
コンポーネント名（{ children }）。

propsについて：
propsは読み取り専用。
propsはコンポーネントの中で書き換え不可。
親→子への一方通行。

コンポーネントは細かすぎると保守性が低くなるし、大きいと再利用性が低くなる。
ここでは「繰り返し使うもの」で分ける。→ヘッダー、ヒーロー、フッター。→コンポーネントフォルダに。

importは相対パスで指定する。

絶対パスでインポートするにはjsconfig.jsonを作成、指定する。

jsconfig.jsonでインポートのエイリアスも設定可。※baseUrlとセット。

layout.jsで全ページ共通のコンポーネントを作っていく。

layoutコンポーネントのように全ページに反映させたい場合はAppコンポーネントを使う。
Appコンポーネントはページの初期化に使われ、ページコンポーネントの親にあたる。
Appコンポーネントをカスタマイズはできず、オーバーライドした_app.jsで行う。

ComponentにpagePropsが渡される。
ページを表示するにはこのComponentとしてページコンポーネントが渡される。

aboutページを作成するため(/about)、pagesディレクトリにabout.jsを作成。
/blogはblogディレクトリの中にindex.jsを作成。
一覧、カテゴリー、記事個別はblogディレクトリに。

それぞれのURLにアクセスするとトップページと同じようにHeroコンポーネントでヒーローが
表示され、_app.jsのLayoutコンポーネントによってヘッダーとフッターが表示される。

カスタムAppコンポーネント_app.jsを使うと共通の設定が適用。
特定のページのレイアウトだけを変更する場合は別途。

imageOn属性で論理属性として設定。（使う側の引数なし。）
→属性があればtrue、なければfalse。
例：<input type="text" required />

デフォルト引数を指定しない場合やundefinedを渡すと、引数の値はundefinedになる。

論理積&& 論理和||
item = expr1 && expr2 
↑expr1がtrueならexpr2を返す。falseならexpr1を返す。
item = expr1 || expr2 
↑expr1がtrueならexpr1を返す。falseならexpr2を返す。

JSXでは条件付きレンダーとして使う。booleanが返ってきてもbooleanはreact要素にはならないため
何も表示されない。そのため、条件付きレンダーは三項演算子で行う。

jsではnull,NaN,undefined,0,'',falseはfalseとして扱われる。
ただし0やNaNは表示される。

next/linkのlinkコンポーネントを使ってリンク設定。
<link></link>で<a>をラップ。linkのhrefでリンク先を指定。
classnameなどの属性は<a>で。
外部リンクは<a>で設定。

データ型はプリミティブ型とオブジェクト型に分けられる。
プリミティブ型はイミュータブルで、値が変わると新しい値が作られる。
プリミティブの型は文字列、数値（numberとbigint）、真偽値、null、undefined、シンボル。

オブジェクト型はミュータブルで、値が変わると新しい値が作られない。
プリミティブ型以外のデータで複数のプリミティブ型やオブジェクト型をまとめたもの。
オブジェクトの型はオブジェクト、配列、関数、正規表現。

reactではスタイリングは大きく4つ
①グローバルスタイル
外部CSSファイルを用意。サイト内の全ての要素が対象。従来のweb制作方式。_app.jsでインポート。
②CSSモジュール
コンポーネント毎にCSSを適用。CSSのスコープをコンポーネントに限定。CSSファイル名をコンポーネント名.module.cssとする。
③CSS in JS
コンポーネント内でCSSを適用。CSSのスコープをコンポーネントに限定。コンポーネント内で<style jsx>で囲む形式をnext.jsではビルトインサポート。他にもstyled-componentsやemotionなどがある。
④インラインスタイル
コンポーネント内でCSSを適用。CSSのスコープをコンポーネントに限定。style属性でCSSを記述。
当該要素のみが対象。メディアクエリや疑似要素などは使用できない。css in jsの一つ。

ここでは
・グローバルスタイルでサイト全体に適用するCSSを設定。（css変数、リセットなど）
・CSSモジュールでコンポーネント毎に適用するCSSを設定。（コンポーネントのスタイル）
・必要に応じてstyled-jsxやインラインスタイルで適用するCSSを補助的に設定。（コンポーネントのスタイル）

CSSmodule
スタイルをimportするとキーがセレクタとして設定されたクラス名。
値はクラス名を元にファイル名とハッシュを追加して生成された生成されたローカルなクラス名。
例：
{
  "title": "styles_title__1Q2Zn",
  "description": "styles_description__3Q2Zn"
}
titleとdescriptionはセレクタとして設定されたクラス名。
styles_title__1Q2Znとstyles_description__3Q2Znはハッシュ値。
ハッシュ値はCSSファイルの中身が変わると変わる。

クラス名によるローカルスコープが適用される。

個別にクラスを指定できないケースでは親スタイルを指定して子要素をスタイルする。

CSSモジュールはクラス名以外は通常のCSSと変わらずグローバルの扱い。

固有のクラスが指定されているケースでは、そのままではローカルなクラス名が生成
されてCSSが適用できない。そのため、ローカルスコープの中のクラス名は:globalや:global()
で囲んでグローバルの扱いにする。
next.jsでは_app.js以外でのグローバルCSSの提供を制限。
これはCSSModuleに関しても同様でスコープを構成しないセレクタではCSSが適用されない。
webpackのcss-loaderのmodulesオプションをfalseにすることでグローバルスタイルを提供できる。
（処理モードをpureとして設定されているため。）

compositionではcompose:を使ってスタイルを継承できる。
compose:の対象はそれよりも前にあるクラス名でないといけない。また複数のクラス名から継承することもできる。

他のCSSModuleファイルからも継承できる。
ただし複数のファイルを読み込む際は読み込み順によるCSSの優先順位は保証されない。
CSSModuleのファイルの中で明確にする。

クラス名はキャメルケースで記述する。ケバブケースでは以下のようにする。
<div classname={styles['text-pastel']}></div>
※キャメルケース：<div classname={styles.textPastel}></div>

IDとアニメーションでもローカルスコープが適用される。

グローバルスタイルの適用。_app.jsに。※他のコンポーネントではインポートはNG
スコープをかける必要はないためCSSmoduleではなく通常のCSSを使用する。
CSS変数（デザイントークン）の設定。カラー、タイポグラフィ、スペースの設定。リセットCSSの設定。

clamp()で画面幅に応じてフォントサイズを変更する。
フォントサイズも。
※clamp()で指定するサイズの値は一時関数の式で。サイトのジェネレーターで計算して取得することもあり。

フォントファミリーはosにインストールされたシステムフォントを指定する。

各コンポーネントのスタイリングではコンポーネントの保守性や再利用性を高くするため、見た目（色やフォントサイズなど）とレイアウト（位置揃え、全体の横幅など）のスタイルを分けて設定。

コンポーネントごとにCSSmoduleを設定する。ディレクトリはどこでもいいが、ここではstylesディレクトリ。

フォントサイズは可変内fluidであるため、画面幅に合わせてフォントサイズは変わる。

共通部分はcomposesする。（.basicを.boxで）

ロゴのボックススタイルon/off切り替えのためboxon属性付加。

classname="{}"では文字列認識。className={}では変数認識。

boxOn属性がtrueの場合はboxクラスを適用、falseの場合はbasicクラスを適用する。

classname={styles.box}もしくはclassname={styles[box]}で適用。
後者の場合、キーとして指定することも可能。

ulの子要素のliやaについては個別にクラスを適用するのは冗長なので、
親要素のulに対してスタイルを適用する。

モバイル時の:hoverの扱い→_app.jsにあるヘッダーやフッターは再描画されないなど
→本参照
従来のweb制作では問題にならなかったが。

next.jsでsassを使用する場合は、sassをインストール。これで/.sassのファイルをインポートしたり、
module.scssをインポートできるようになる。

共通したレイアウトのCSSは1つのCSSModuleファイルで管理し、各コンポーネントでcomposesで読み込む。
ここでは両端揃え、横並び（基本形）、横並び（中央揃え）でそれぞれ作る。
並べる子要素の間隔（gap）や横幅などは、コンポーネントごとのスタイルで指定する。

util.module.scssで用意したcssを<div className={styles.flexContainer}>で囲んで
適用する形に統一すると将来的に<div>をレイアウト用のコンポーネントに変更するといったことができる・

横幅を整えるため、containerコンポーネントを作成。

ヘッダーは大きい方の最大幅1280pxにする。属性largeをつけそれがfalseの場合は小さい方の最大幅1152pxにする。

アバウトページに追加した本文のレイアウト調整。レイアウトのスタイルはPostBodyコンポーネントで管理。

フクロウセレクタはユニバーサルセレクタ（＊）と次の兄弟要素を指定する隣接セレクタ（＋）の組み合わせでつくられた「＊＋＊」というセレクタのことです。.stack > * + * を使う場合、
CSSのセレクタとしてこの指定方法をを使うことで二番目以降の要素を指定することができます。最初以外の要素と言い換えることもできます。

プロパティの値として revert を指定することで、プロパティ値をブラウザの初期値に戻すことができます。

margin-top: var(--stack-space, 1.5em); の意味
→ 上記のスタイル定義は、--stack-spaceというカスタムプロパティが定義されている場合はその値を、定義されていない場合は1.5emを上方の余白に適用するという意味になります。

サイズが一律の場合はflexboxやgridが便利。一方、サイズがバラバラの場合は、フクロウセレクタが柔軟に対応できる。
特定の子要素のスタイルを変更したい場合も上書きで対応。
また、「margin-top」などで直接子要素側で指定すると、その要素が一つ目となった場合には、不要なマージンが入るため、
css変数を駆使して管理。

2段組のレイアウト、main,saidebar,大枠のwrapperを一つのコンポーネントで管理する。
普通は横並びのcssを適用すればいいが、この2段組のレイアウトでは他のコンテンツも追加するので。
一つのファイルで複数のコンポーネントを用意するため、名前付きエクスポートを使用する。

サイドバーの中身は他のコンポーネントになるため、ブロック、インラインどちらでも右揃えになるような
cssにする。

:is()を使用すると、繰り返しを減らせる

中身に合わせた横幅はfit-content。これに左マージンをautoにすることで右揃えになる。
ただし、fit-contentを全ての要素に適用するとsafariではレイアウトが崩れるため、使われる主要ブロック
要素にのみ適用する。

2段組のメインとサイドバーはTwoColumnのサブコンポーネントとしても可。
↓
TwoColumn.Main = function Main({ children }) {
  return <div className={styles.main}>{children}</div>;
};
TwoColumn.Sidebar = function Sidebar({ children }) {
  return <div className={styles.sidebar}>{children}</div>;
};

next.jsはwebfontを最適化してくれる。
<link />で設定。
開発モードでは<Link />がそのまま出力されるが、ビルドすると<style>で埋め込まれる。

next.jsではpublicフォルダに画像を置いて表示する方法と、next/imageを利用する場合がある。

<Image />は必要な解像度の画像を生成。レスポンシブのコードも生成。
レイアウトシフトにも対応。ただし、width、heightを指定する必要があるのでパラメータは多くなる。

レイアウトシフト対策のためにspanタグが多くなる。

一般的なレスポンスイメージでは画像ソースの選択を<picture>や<source>で行うが、
next/imageではsrcSetを使う。
→画像処理apiを使う関係からSSGでは使えない。
Next.jsではSSGはあまりお勧めしない。（使える機能が限られる）

next/imageではレイアウトモードに応じて異なるレスポンシブイメージのコードを生成。
レイアウトモードは<Image />のlayoutプロパティで指定。

fill: 画像を親要素にフィットさせる。画像のアスペクト比は維持される。
fixed: 画像のサイズを指定する。画像のアスペクト比は維持される。
intrinsic: 画像のサイズを指定する。画像のアスペクト比は維持されない。
responsive: 画像のサイズを指定する。画像のアスペクト比は維持される。

レイアウトモードがresponsive、fillの場合は、サイズが可変なレスポンシブイメージのコードが生成される。
自動で用意された様々な解像度の画像はsrcset属性とurlで横幅が指定される。
画像セットのから画像を選択する条件はsize属性。

画面幅と共にデバイスのDPRも考慮され最適なサイズの画像が選択される。

レイアウトモードがfixed、intrinsicの場合は、サイズが固定な画像のレスポンスを生成。
この場合、DPRが条件として選択される。
intrinsicは表示サイズが小さいほど大きな画像を読み込むため注意。

レイアウトシフトにも対応。
横幅、高さ、縦横比のうち2つ以上を指定する必要があるが、
シンプルな設定ではwidth、heightを指定。
→古いブラウザはこの手法は未対応なのでspanタグを付加。
※next.js v12からはnext/future/imageを使うことで対応。(spanは不要、がcssは自分で用意)

spanタグでのレイアウトシフト対策で、サイズが可変な場合、固定な場合でそれぞれある（→本）

遅延読み込みはnext.jsでは有効になってる。（レイアウトシフト対策で表示エリアは確保）

<Image />にloading="eager"を指定すると遅延読み込みを無効にできる。
が、パフォーマンスに影響が出るので、遅延読み込みを無効にする場合は、
next.config.jsで設定する。
または、<Image />のpriorityプロパティをtrueにする。
↑LCP対策で。

レイアウトモードはfillにするとwidth,height属性は省略できるが、その場合は、レイアウトシフトを含めた
コントロールをcssで設定する必要がある。

外部サイトのURLはnext.config.jsで設定する。

ローカルの画像はインポートして表示。
インポートしたら色々な属性を持つオブジェクトが返ってくる。
また、ローカルの画像はwidth、heightを指定する必要もなくなる。→自動で取得してくれる。

layout属性は標準はintrinsice。

サイズを可変にする場合：responsive
特定のサイズで切り抜く場合：fill
サイズを固定にする場合：fixedまたはintrinsic
詳細は本にて。

quality属性、priority属性、unoptimized属性、placeholder属性、blurDataURL属性

about.jsに<Image />追加。画像のwidthとheightは自動で取得される。
alt属性は空にして装飾的な画像とする。
layout属性はresponsiveに、<Container>の絡みでsize属性を本のようにコード。
→最適な画像サイズが選定される。※srcset属性が自動で出力される。

LCP対策のため、priority属性をtrueにする。

placeholder属性は画像の読み込み前に表示する画像を指定する。ここでは属性を「blur」とする
ブラー画像の生成には、blurDataURL属性を指定する必要があるがeyecatchから取得するので指定する必要はない。

全ての画像にブラー画像からのフェードイン適用のため、global.cssにtransition適用。

{imageOn && (
  <figure>....</figure>
)}
と複数行になる場合は()で囲む。

画像を構成する<span>と<img>は生成されているが、親要素の<figure>含め
表示サイズを指定しないと画像は表示されない。

子要素のレイアウトモードをresponsiveにした場合親要素の横幅に合わせて画像のサイズが変わる。
しかし親要素は横幅を指定していないので、子要素の中身に合わせたサイズになる。
→親要素の横幅を指定する。（next/imageのコードを変えるのは難しいので）

